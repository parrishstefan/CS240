     1                                  ;****************************************************************************************************************************
     2                                  ;Program name: "Basic Float Operations".  This program demonstrates the input and output of a float number and demonstrates *
     3                                  ;some basic math operations using float numbers.  Copyright (C) 2020 Floyd Holliday.                                        *
     4                                  ;                                                                                                                           *
     5                                  ;This file is part of the software program "Basic Float Operations".                                                        *
     6                                  ;Basic Float Operations is free software: you can redistribute it and/or modify it under the terms of the GNU General Public*
     7                                  ;License version 3 as published by the Free Software Foundation.                                                            *
     8                                  ;Basic Float Operations is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the       *
     9                                  ;implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more      *
    10                                  ;details.  A copy of the GNU General Public License v3 is available here:  <https:;www.gnu.org/licenses/>.                  *
    11                                  ;****************************************************************************************************************************
    12                                  
    13                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
    14                                  ;
    15                                  ;Author information
    16                                  ;  Author name: Floyd Holliday
    17                                  ;  Author email: holliday@fullerton.edu
    18                                  ;
    19                                  ;Program information
    20                                  ;  Program name: Basic Float Operations
    21                                  ;  Programming languages: One modules in C++ and one module in X86
    22                                  ;  Date program began: 2014-Aug-25
    23                                  ;  Date of last update: 2014-Sep-29
    24                                  ;  Date comments upgraded: 2020-July-04
    25                                  ;  Date open source license added: 2020-Sep-20
    26                                  ;  Files in this program: fp-io-driver.cpp, fp-io.asm 
    27                                  ;  Status: Finished.
    28                                  ;  References consulted: Seyfarth, Chapter 11
    29                                  ;  Future upgrade possible: software to validate inputs and reject non-float inputs
    30                                  ;
    31                                  ;Purpose
    32                                  ;  This program will demonstrate how to input a single float number, multiply that inputted number by a floating point
    33                                  ;  constant and then output the results.
    34                                  ;  To students enrolled in 240 class: this program includes a secondary purpose, which is to demonstrate how to do a 
    35                                  ;     state component back up using instructions xsave and xrstor.  For the most part that is superflous material. You may
    36                                  ;     safely disregard the two sections on "state component backup".  By the way, you still have to save all the GPRs 
    37                                  ;     and restore them the long way.
    38                                  ;
    39                                  ;This file
    40                                  ;  File name: fp-io.asm
    41                                  ;  Language: X86 with Intel syntax.
    42                                  ;  Max page width: 132 columns
    43                                  ;  Assemble: nasm -f elf64 -l fp-io.lis -o fp-io.o fp-io.asm
    44                                  
    45                                  
    46                                  ;===== Begin code area ========================================================================================================
    47                                  
    48                                  extern printf                                               ;External C++ function for writing to standard output device
    49                                  
    50                                  extern scanf                                                ;External C++ function for reading from the standard input device
    51                                  
    52                                  global floating_point_io                                    ;This makes floating_point_io callable by functions outside of this file.
    53                                  
    54                                  three_point_zero equ 0x4008000000000000                     ;Use the hex expression for 64-bit floating point 3.0
    55                                  
    56                                  segment .data                                               ;Place initialized data here
    57                                  
    58                                  ;===== Declare some messages ==================================================================================================
    59                                  
    60 00000000 546869732058383620-     initialmessage db "This X86 program will demonstrate the input and output of 8-byte floating point numbers.", 10, 0
    60 00000009 70726F6772616D2077-
    60 00000012 696C6C2064656D6F6E-
    60 0000001B 737472617465207468-
    60 00000024 6520696E7075742061-
    60 0000002D 6E64206F7574707574-
    60 00000036 206F6620382D627974-
    60 0000003F 6520666C6F6174696E-
    60 00000048 6720706F696E74206E-
    60 00000051 756D626572732E0A00 
    61                                  
    62 0000005A 456E74657220612066-     promptmessage db "Enter a floating point number in base 10: ", 0
    62 00000063 6C6F6174696E672070-
    62 0000006C 6F696E74206E756D62-
    62 00000075 657220696E20626173-
    62 0000007E 652031303A2000     
    63                                  
    64 00000085 5468652076616C7565-     outputmessage db "The value of %1.18lf divided by %1.18lf is %1.18lf", 10, 0
    64 0000008E 206F662025312E3138-
    64 00000097 6C6620646976696465-
    64 000000A0 642062792025312E31-
    64 000000A9 386C66206973202531-
    64 000000B2 2E31386C660A00     
    65                                  
    66 000000B9 546865207873617665-     xsavenotsupported.notsupportedmessage db "The xsave instruction and the xrstor instruction are not supported in this microprocessor.", 10
    66 000000C2 20696E737472756374-
    66 000000CB 696F6E20616E642074-
    66 000000D4 686520787273746F72-
    66 000000DD 20696E737472756374-
    66 000000E6 696F6E20617265206E-
    66 000000EF 6F7420737570706F72-
    66 000000F8 74656420696E207468-
    66 00000101 6973206D6963726F70-
    66 0000010A 726F636573736F722E-
    66 00000113 0A                 
    67 00000114 486F77657665722C20-                                           db "However, processing will continue without backing up state component data", 10, 0
    67 0000011D 70726F63657373696E-
    67 00000126 672077696C6C20636F-
    67 0000012F 6E74696E7565207769-
    67 00000138 74686F757420626163-
    67 00000141 6B696E672075702073-
    67 0000014A 7461746520636F6D70-
    67 00000153 6F6E656E7420646174-
    67 0000015C 610A00             
    68                                  
    69 0000015F 4920686F706520796F-     goodbye db "I hope you like working with 8-byte numbers while we wait for the 128-bit X86 processor.  "
    69 00000168 75206C696B6520776F-
    69 00000171 726B696E6720776974-
    69 0000017A 6820382D6279746520-
    69 00000183 6E756D626572732077-
    69 0000018C 68696C652077652077-
    69 00000195 61697420666F722074-
    69 0000019E 6865203132382D6269-
    69 000001A7 74205838362070726F-
    69 000001B0 636573736F722E2020 
    70 000001B9 5468656E20796F7527-             db "Then you'll enjoy 16 byte floating point numbers.", 10, 0
    70 000001C2 6C6C20656E6A6F7920-
    70 000001CB 313620627974652066-
    70 000001D4 6C6F6174696E672070-
    70 000001DD 6F696E74206E756D62-
    70 000001E6 6572732E0A00       
    71                                  
    72 000001EC 257300                  stringformat db "%s", 0                                     ;general string format
    73                                  
    74 000001EF 257300                  xsavenotsupported.stringformat db "%s", 0
    75                                  
    76 000001F2 256C6600                eight_byte_format db "%lf", 0                               ;general 8-byte float format
    77                                  
    78                                  segment .bss                                                ;Place un-initialized data here.
    79                                  
    80                                  align 64                                                    ;Insure that the inext data declaration starts on a 64-byte boundar.
    81 00000000 <res 00000340>          backuparea resb 832                                         ;Create an array for backup storage having 832 bytes.
    82                                  
    83                                  ;===== Begin executable instructions here =====================================================================================
    84                                  
    85                                  segment .text                                               ;Place executable instructions in this segment.
    86                                  
    87                                  floating_point_io:                                          ;Entry point.  Execution begins here.
    88                                  
    89                                  ;=========== Back up all the GPRs whether used in this program or not =========================================================
    90                                  
    91 00000000 55                      push       rbp                                              ;Save a copy of the stack base pointer
    92 00000001 4889E5                  mov        rbp, rsp                                         ;We do this in order to be 100% compatible with C and C++.
    93 00000004 53                      push       rbx                                              ;Back up rbx
    94 00000005 51                      push       rcx                                              ;Back up rcx
    95 00000006 52                      push       rdx                                              ;Back up rdx
    96 00000007 56                      push       rsi                                              ;Back up rsi
    97 00000008 57                      push       rdi                                              ;Back up rdi
    98 00000009 4150                    push       r8                                               ;Back up r8
    99 0000000B 4151                    push       r9                                               ;Back up r9
   100 0000000D 4152                    push       r10                                              ;Back up r10
   101 0000000F 4153                    push       r11                                              ;Back up r11
   102 00000011 4154                    push       r12                                              ;Back up r12
   103 00000013 4155                    push       r13                                              ;Back up r13
   104 00000015 4156                    push       r14                                              ;Back up r14
   105 00000017 4157                    push       r15                                              ;Back up r15
   106 00000019 9C                      pushf                                                       ;Back up rflags
   107                                  
   108                                  
   109                                  ;==============================================================================================================================
   110                                  ;===== Begin State Component Backup ===========================================================================================
   111                                  ;==============================================================================================================================
   112                                  
   113                                  ;=========== Before proceeding verify that this computer supports xsave and xrstor ============================================
   114                                  ;Bit #26 of rcx, written rcx[26], must be 1; otherwise xsave and xrstor are not supported by this computer.
   115                                  ;Preconditions: rax holds 1.
   116 0000001A B801000000              mov        rax, 1
   117                                  
   118                                  ;Execute the cpuid instruction
   119 0000001F 0FA2                    cpuid
   120                                  
   121                                  ;Postconditions: If rcx[26]==1 then xsave is supported.  If rcx[26]==0 then xsave is not supported.
   122                                  
   123                                  ;=========== Extract bit #26 and test it ======================================================================================
   124                                  
   125 00000021 4881E100000004          and        rcx, 0x0000000004000000                          ;The mask 0x0000000004000000 has a 1 in position #26.  Now rcx is either all zeros or
   126                                                                                              ;has a single 1 in position #26 and zeros everywhere else.
   127 00000028 4883F900                cmp        rcx, 0                                           ;Is (rcx == 0)?
   128 0000002C 742A                    je         xsavenotsupported                                ;Skip the section that backs up state component data.
   129                                  
   130                                  ;========== Call the function to obtain the bitmap of state components ========================================================
   131                                  
   132                                  ;Preconditions
   133 0000002E B80D000000              mov        rax, 0x000000000000000d                          ;Place 13 in rax.  This number is provided in the Intel manual
   134 00000033 B900000000              mov        rcx, 0                                           ;0 is parameter for subfunction 0
   135                                  
   136                                  ;Call the function
   137 00000038 0FA2                    cpuid                                                       ;cpuid is an essential function that returns information about the cpu
   138                                  
   139                                  ;Postconditions (There are 2 of these):
   140                                  
   141                                  ;1.  edx:eax is a bit map of state components managed by xsave.  At the time this program was written (2014 June) there were exactly 3 state components.  Therefore, bits
   142                                  ;    numbered 2, 1, and 0 are important for current cpu technology.
   143                                  ;2.  ecx holds the number of bytes required to store all the data of enabled state components. [Post condition 2 is not used in this program.]
   144                                  ;This program assumes that under current technology (year 2014) there are at most three state components having a maximum combined data storage requirement of 832 bytes.
   145                                  ;Therefore, the value in ecx will be less than or equal to 832.
   146                                  
   147                                  ;Precaution: As an insurance against a future time when there will be more than 3 state components in a processor of the X86 family the state component bitmap is masked to
   148                                  ;allow only 3 state components maximum.
   149                                  
   150 0000003A 41BF07000000            mov        r15, 7                                           ;7 equals three 1 bits.
   151 00000040 4C21F8                  and        rax, r15                                         ;Bits 63-3 become zeros.
   152 00000043 41BF00000000            mov        r15, 0                                           ;0 equals 64 binary zeros.
   153 00000049 4C21FA                  and        rdx, r15                                         ;Zero out rdx.
   154                                  
   155                                  ;========== Save all the data of all three components except GPRs =============================================================
   156                                  
   157                                  ;The instruction xsave will save those state components with on bits in the bitmap.  At this point edx:eax continues to hold the state component bitmap.
   158                                  
   159                                  ;Precondition: edx:eax holds the state component bit map.  This condition has been met by the two pops preceding this statement.
   160 0000004C 0FAE2425[00000000]      xsave      [backuparea]                                     ;All the data of state components managed by xsave have been written to backuparea.
   161                                  
   162 00000054 6AFF                    push qword -1                                               ;Set a flag (-1 = true) to indicate that state component data were backed up.
   163 00000056 EB20                    jmp        startapplication
   164                                  
   165                                  ;========== Show message xsave is not supported on this platform ==============================================================
   166                                  xsavenotsupported:
   167                                  
   168 00000058 B800000000              mov        rax, 0
   169 0000005D 48BF-                   mov        rdi, .stringformat
   169 0000005F [EF01000000000000] 
   170 00000067 48BE-                   mov        rsi, .notsupportedmessage                        ;"The xsave instruction is not suported in this microprocessor.
   170 00000069 [B900000000000000] 
   171 00000071 E8(00000000)            call       printf
   172                                  
   173 00000076 6A00                    push qword 0                                                ;Set a flag (0 = false) to indicate that state component data were not backed up.
   174                                  
   175                                  ;==============================================================================================================================
   176                                  ;===== End of State Component Backup ==========================================================================================
   177                                  ;==============================================================================================================================
   178                                  
   179                                  
   180                                  ;==============================================================================================================================
   181                                  startapplication: ;===== Begin the application here: demonstrate floating point i/o ===========================================
   182                                  ;==============================================================================================================================
   183                                  
   184                                  ;Show the initial message
   185 00000078 B800000000              mov qword  rax, 0                                           ;No data from SSE will be printed
   186 0000007D 48BF-                   mov        rdi, stringformat                                ;"%s"
   186 0000007F [EC01000000000000] 
   187 00000087 48BE-                   mov        rsi, initialmessage                              ;"This X86 program will demonstrate the input and output of 8-byte ... "
   187 00000089 [0000000000000000] 
   188 00000091 E8(00000000)            call       printf                                           ;Call a library function to make the output
   189                                  
   190                                  
   191                                  ;Prompt for floating point number
   192 00000096 B800000000              mov qword  rax, 0                                           ;No data from SSE will be printed
   193 0000009B 48BF-                   mov        rdi, stringformat                                ;"%s"
   193 0000009D [EC01000000000000] 
   194 000000A5 48BE-                   mov        rsi, promptmessage                               ;"Enter a floating point number in base 10: "
   194 000000A7 [5A00000000000000] 
   195 000000AF E8(00000000)            call       printf                                           ;Call a library function to make the output
   196                                  
   197                                  
   198                                  ;Obtain a floating point number from the standard input device and store a copy in xmm0
   199 000000B4 6A00                    push qword 0                                                ;Reserve 8 bytes of storage for the incoming number
   200 000000B6 B800000000              mov qword  rax, 0                                           ;SSE is not involved in this scanf operation
   201 000000BB 48BF-                   mov        rdi, eight_byte_format                           ;"%lf"
   201 000000BD [F201000000000000] 
   202 000000C5 4889E6                  mov        rsi, rsp                                         ;Give scanf a point to the reserved storage
   203 000000C8 E8(00000000)            call       scanf                                            ;Call a library function to do the input work
   204 000000CD F20F100424              movsd      xmm0, [rsp]                                      ;Copy the inputted number to xmm0
   205 000000D2 58                      pop        rax                                              ;Make free the storage that was used by scanf
   206                                  
   207                                  ;Divide the inputted number by a constant
   208 000000D3 F20F10D0                movsd      xmm2, xmm0                                       ;There are 2 copies of the inputted number: xmm0 and xmm2
   209 000000D7 48BB00000000000008-     mov        rbx, three_point_zero                            ;3.0 is placed in rbx, and is ready to be pushed on the stack.
   209 000000E0 40                 
   210 000000E1 53                      push       rbx                                              ;Place the constant on the integer stack
   211 000000E2 F20F5E1424              divsd      xmm2, [rsp]                                      ;Divide the input number by the constant
   212 000000E7 F20F100C24              movsd      xmm1, [rsp]                                      ;Copy the divisor to xmm1
   213 000000EC 58                      pop        rax                                              ;Discard the divisor from the integer stack
   214                                  
   215                                  ;Save a copy of the quotient before calling printf
   216 000000ED 6A00                    push qword 0                                                ;Reserve 8 bytes of storage
   217 000000EF F20F111424              movsd      [rsp], xmm2                                      ;Place a backup copy of the quotient in the reserved storage
   218                                  
   219                                  ;Show the result of the division operation
   220 000000F4 B803000000              mov        rax, 3                                           ;3 floating point numbers will be outputted
   221 000000F9 48BF-                   mov        rdi, outputmessage                               ;"The value of %1.18lf divided by %1.18lf is %1.18lf"
   221 000000FB [8500000000000000] 
   222 00000103 E8(00000000)            call       printf                                           ;Call a library function to do the hard work
   223                                  
   224                                  ;Output the concluding message
   225 00000108 B800000000              mov qword  rax, 0                                           ;No data from SSE will be printed
   226 0000010D 48BF-                   mov        rdi, stringformat                                ;"%s"
   226 0000010F [EC01000000000000] 
   227 00000117 48BE-                   mov        rsi, goodbye                                     ;"This summation program will now return to the driver.  Have a nice day."
   227 00000119 [5F01000000000000] 
   228 00000121 E8(00000000)            call       printf                                           ;Call a llibrary function to do the hard work.
   229                                  
   230                                  
   231                                  ;===== Retrieve a copy of the quotient that was backed up earlier =============================================================
   232                                  
   233 00000126 415E                    pop        r14                                              ;A copy of the quotient is in r14 (temporary storage)
   234                                  
   235                                  ;Now the stack is in the same state as when the application area was entered.  It is safe to leave this application area.
   236                                  
   237                                  
   238                                  ;==============================================================================================================================
   239                                  ;===== Begin State Component Restore ==========================================================================================
   240                                  ;==============================================================================================================================
   241                                  
   242                                  ;Check the flag to determine if state components were really backed up
   243 00000128 5B                      pop        rbx                                              ;Obtain a copy of the flag that indicates state component backup or not.
   244 00000129 4883FB00                cmp        rbx, 0                                           ;If there was no backup of state components then jump past the restore section.
   245 0000012D 7426                    je         setreturnvalue                                   ;Go to set up the return value.
   246                                  
   247                                  ;Continue with restoration of state components;
   248                                  
   249                                  ;Precondition: edx:eax must hold the state component bitmap.  Therefore, go get a new copy of that bitmap.
   250                                  
   251                                  ;Preconditions for obtaining the bitmap from the cpuid instruction
   252 0000012F B80D000000              mov        rax, 0x000000000000000d                          ;Place 13 in rax.  This number is provided in the Intel manual
   253 00000134 B900000000              mov        rcx, 0                                           ;0 is parameter for subfunction 0
   254                                  
   255                                  ;Call the function
   256 00000139 0FA2                    cpuid                                                       ;cpuid is an essential function that returns information about the cpu
   257                                  
   258                                  ;Postcondition: The bitmap in now in edx:eax
   259                                  
   260                                  ;Future insurance: Make sure the bitmap is limited to a maximum of 3 state components.
   261 0000013B 41BF07000000            mov        r15, 7
   262 00000141 4C21F8                  and        rax, r15
   263 00000144 41BF00000000            mov        r15, 0
   264 0000014A 4C21FA                  and        rdx, r15
   265                                  
   266 0000014D 0FAE2C25[00000000]      xrstor     [backuparea]
   267                                  
   268                                  ;==============================================================================================================================
   269                                  ;===== End State Component Restore ============================================================================================
   270                                  ;==============================================================================================================================
   271                                  
   272                                  
   273                                  setreturnvalue:
   274 00000155 4156                    push       r14                                              ;r14 continues to hold the first computed floating point value.
   275 00000157 F20F100424              movsd      xmm0, [rsp]                                      ;That first computed floating point value is copied to xmm0[63-0]
   276 0000015C 415E                    pop        r14                                              ;Reverse the push of two lines earlier.
   277                                  
   278                                  ;Restore the original values to the GPRs
   279 0000015E 9D                      popf                                                        ;Restore rflags
   280 0000015F 415F                    pop        r15                                              ;Restore r15
   281 00000161 415E                    pop        r14                                              ;Restore r14
   282 00000163 415D                    pop        r13                                              ;Restore r13
   283 00000165 415C                    pop        r12                                              ;Restore r12
   284 00000167 415B                    pop        r11                                              ;Restore r11
   285 00000169 415A                    pop        r10                                              ;Restore r10
   286 0000016B 4159                    pop        r9                                               ;Restore r9
   287 0000016D 4158                    pop        r8                                               ;Restore r8
   288 0000016F 5F                      pop        rdi                                              ;Restore rdi
   289 00000170 5E                      pop        rsi                                              ;Restore rsi
   290 00000171 5A                      pop        rdx                                              ;Restore rdx
   291 00000172 59                      pop        rcx                                              ;Restore rcx
   292 00000173 5B                      pop        rbx                                              ;Restore rbx
   293 00000174 5D                      pop        rbp                                              ;Restore rbp
   294                                  
   295 00000175 C3                      ret                                                         ;No parameter with this instruction.  This instruction will pop 8 bytes from
   296                                                                                              ;the integer stack, and jump to the address found on the stack.
   297                                  ;========== End of program fp-io.asm ======================================================================================================================================
   298                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
